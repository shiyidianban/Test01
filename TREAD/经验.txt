1. redis类型 String Hash List Set Zset
2. 缓存穿透、缓存击穿、缓存雪崩区别和解决方案
	1.缓存处理流程
		前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。
	2.缓存穿透
		描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
		解决方案：正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询          到的对象，放进缓存并设置生存时间。如果数据库查询对象为空，则不放进缓存。解决缓存穿透的思路就是：如果从数据库
	          查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。
	3.缓存击穿
		描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
		解决方案：1.设置热点数据永不过期（唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)
				可能访问的是老数据，导致数据不一致的问题）
				(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
				(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期
			 2.使用互斥锁解决，伪代码如下：
			 		public String getData(String key){
				        String result = getDataFromRedis(key);
				        try {
				            if(result == null){
				                if(redisLock.tryLock()){
				                    result = getDataFromDB(key);
				                    if(result != null){
				                        putRedis(key,result);
				                    }
				                }
				            }else{
				                Thread.sleep(100);
				                getData(key);
				            }
				        }catch (Exception e){
				 
				        }finally {
				            redisLock.unLock();
				        }
				        return result;
				    ｝
	4.缓存雪崩：是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击
		穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。是指在某一个时间段，缓存集中过期失效。
		产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。
		1.一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。
		其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，那么那个时候数据库能顶住压力，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

3. MySQL索引种类
	普通索引：仅加速查询，
	唯一索引：加速查询 + 列值唯一（可以有null），
	组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，
	主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个，
	全文索引：对文本的内容进行分词，进行搜索，即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。
   MySQL索引种类：
   	Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。
   	1. FULLTEXT
		即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。
	2. HASH
		由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
	3. BTREE
		BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
	4. RTREE
		RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找　

4. JVM内存

5. GC机制
6. java锁机制
7. Spring的AOP实现原理和IOC注入
	(1). IoC（Inversion of Control）是指容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接操控。控制权由应用代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系；IoC还有另外一个名字——“依赖注入（Dependency Injection）”。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。
	(2). 在Spring的工作方式中，所有的类都会在spring容器中登记，告诉spring这是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
	(3). 在系统运行中，动态的向某个对象提供它所需要的其他对象。  
	(4). 依赖注入的思想是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。 注入方式有两种：依赖注入和设置注入； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。
	AOP（Aspect Oriented Programming）
	(1). AOP面向方面编程基于IoC，是对OOP的有益补充；
	(2). AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了 多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的 逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。
	(3). AOP代表的是一个横向的关 系，将“对象”比作一个空心的圆柱体，其中封装的是对象的属性和行为；则面向方面编程的方法，就是将这个圆柱体以切面形式剖开，选择性的提供业务逻辑。而 剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹，但完成了效果。
	(4). 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。
	(5). Spring实现AOP：JDK动态代理和CGLIB代理 JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理；其核心的两个类是InvocationHandler和Proxy。 CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。     使用AspectJ注入式切面和@AspectJ注解驱动的切面实际上底层也是通过动态代理实现的。
	(6). AOP使用场景：                     

		Authentication 权限检查        

		Caching 缓存        

		Context passing 内容传递        

		Error handling 错误处理        

		Lazy loading　延迟加载        

		Debugging　　调试      

		logging, tracing, profiling and monitoring　日志记录，跟踪，优化，校准        

		Performance optimization　性能优化，效率检查        

		Persistence　　持久化        

		Resource pooling　资源池        

		Synchronization　同步        

		Transactions 事务管理    

		另外Filter的实现和struts2的拦截器的实现都是AOP思想的体现。

8. SpringCloud的云服务
	1、什么是 Spring Cloud？
		Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。

	2、使用 Spring Cloud 有什么优势？
		使用 Spring Boot 开发分布式微服务时，我们面临以下问题：
		（1）与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。
		（2）服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。
		（3）冗余-分布式系统中的冗余问题。
		（4）负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。
	3、服务注册和发现是什么意思？Spring Cloud 如何实现？
		当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。
	4、Spring Cloud 和dubbo区别?
		（1）服务调用方式 dubbo是RPC springcloud Rest Api
		（2）注册中心,dubbo 是zookeeper，springcloud是eureka，也可以是zookeeper
		（3）服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。
	5、SpringBoot和SpringCloud的区别？
		SpringBoot专注于快速方便的开发单个个体微服务。
		SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，
		为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
		SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系.
		SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
	6、负载平衡的意义什么？
		在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。

9. Java多线程
	1. 继承Thread类
	2. 实现Runnable接口
	3. 创建线程池，7个参数，参数至少有5个
		int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。
  		int maximumPoolSize, // 线程数的上限
  		long keepAliveTime,//多余的空闲线程存活时间。当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。 
  		TimeUnit unit, //keepAliveTime的时间单位
 		BlockingQueue<Runnable> workQueue, // 任务的排队队列
  		ThreadFactory threadFactory, // 新线程的产生方式
 		RejectedExecutionHandler handler) // 拒绝策略

 		jdk默认提供了四种拒绝策略：
 			CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大
 			AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。
 			DiscardPolicy - 直接丢弃，其他啥都没有
 			DiscardOldestPolicy -  当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入

 	run()，实质上是方法，作用是运行线程，无法开启新的线程
	start()，创建启动新的线程，可以实现多线程工作。通过start()使得线程处于就绪状态，在获得CPU时间片后通过run()开始运行

10. Object的wait和Thread的sleep机制
	线程获取到对象锁之后，sleep时不会释放对象锁，其他线程也不能获取到对象锁。直到线程sleep结束，其他线程才能获取到对象锁。
	线程获取到对象锁之后，执行wait()就会释放对象锁，同时线程挂起，直到其他线程获取到对象锁并执行notify()后，线程重新开始运行。
11. hashMap,hashTable,ConcurrentHashMap的原理
12. java的类加载机制
	加载 验证 准备 解析 初始化
	加载
		类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。
	验证
		目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。
	准备
		为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。
	解析
		这里主要的任务是把常量池中的符号引用替换成直接引用
	初始化
		这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）
	使用
		主动引用：
			通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。
			通过反射方式执行以上三种行为。
			初始化子类的时候，会触发父类的初始化。
			作为程序入口直接运行时（也就是直接调用main方法）。
		被动引用：
			引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
			定义类数组，不会引起类的初始化。
			引用类的常量，不会引起类的初始化。
	卸载
		该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
		加载该类的ClassLoader已经被回收；
		该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
13. MySQL的锁机制
	MySQL中锁的种类：

	MySQL中锁的种类很多，有常见的表锁和行锁，也有新加入的Metadata，Lock等等,表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。

	行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强，MySQL一般都是用行锁来处理并发事务。这里主要讨论的也就是行锁。



14. MySQL的引擎
	InnoDB
		这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O。
	MyISAM
		该存储引擎管理非事务性表，提供高速存储和检索，支持全文搜索。
	MEMORY
		提供内存中的表，以前称为堆。它在RAM中处理所有数据，以便比在磁盘上存储数据更快地访问。用于快速查找引用和其他相同的数据。
	MERGE
		将多个类似的MyISAM表分组为一个表，可以处理非事务性表，默认情况下包括这些表。
15. MySQL 隔离级别
	一、事务特性
		1.原子性
		事务是一个原子操作单元，事务中包含的所有操作要么都做，要么都不做，没有第三种情况。
		2.一致性
		事务操作前和操作后都必须满足业务规则约束，比如说A向B转账，转账前和转账后AB两个账户的总金额必须是一致的。
		3.隔离性
		隔离性是数据库允许多个并发事务同时对数据进行读写的能力，隔离性可以防止事务并发执行时由于交叉执行导致数据不一致的问题。
		4.持久性
		事务完成后，对数据的修改是永久的，即使出现系统故障也不会丢失。
	二、并发问题
		1.更新丢失
		当两个事务选择同一行，然后更新数据，由于每个事务都不知道其他事务的存在，就会发生丢失更新的问题，（你我同时读取同一行数据，进行修改，你commit之后我也commit，那么我的结果将会覆盖掉你的结果）。
		2.脏读
		一个事务正在对一条记录做修改，在这个事务提交之前，别的事务读取到了这个事务修改之后的数据，也就是说，一个事务读取到了其他事务还没有提交的数据，就叫做脏读。
		3.不可重复读
		一个事务读某条数据读两遍，读到的是不一样的数据，也就是说，一个事务在进行中读取到了其他事务对旧数据的修改结果，（比如说 我开一个事务 修改某条数据 先查后改 执行修改动作的时候发现这条数据已经被别的事务删掉了）
		4.幻读
		一个事务中，读取到了其他事务新增的数据，仿佛出现了幻象。（幻读与不可重复读类似，不可重复读是读到了其他事务update/delete的结果，幻读是读到了其他事务insert的结果）
	三、隔离级别
		1.未提交读（read-uncommitted）
		在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
		2.已提交读（read-committed）
		这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理期间可能会有新的commit，所以同一select可能返回不同结果。

		在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read）。

		3.可重复读（repetable-read）
		这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
		MySQL默认隔离级别，在一个事务中，直到事务结束前，都可以反复读取到事务刚开始时看到的数据，并一直不会发生变化，避免了脏读、不可重复读现象，但是它还是无法解决幻读问题。
		4.可串行化（serializable）
		这是最高的隔离级别，它强制事务串行执行，避免了前面说的幻读现象，简单来说，它会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁争用问题。

	-- 查看当前数据库的隔离级别
	SHOW VARIABLES LIKE "%tx_isolation%"

16. 内存泄漏和内存溢出的区别与解决方式

17. 网络层结构
	应用层 文件传输，电子邮件，文件服务，虚拟终端； TFTP,HTTP,SNMP,FTP,SMTP,DNS,RIP,TELNET
	表示层 数据格式化，代码转换，数据加密； 没有协议
	会话层 解除或建立与别的接点的联系；没有协议
	传输层 提供端对端的接口； TCP,UDP
	网络层 为数据包选择路由； IP,ICMP,OSPF,BGP,IGMP,ARP,RARP
	数据链路层 传输有地址的帧以及错误检测功能； SLIP,CSLIP,PPP,MTU,ARP,RARP
	物理层 以二进制数据形式在物理媒体上传输数据； ISO2110,IEEE802,IEEE802.2

	http1.0和2.0的区别

18. 操作系统模块
	操作系统是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。

	处理器管理
		处理器是完成运算和控制的设备。在多道程序运行时，每个程序都需要一个处理器，而一般计算机中只有一个处理器。操作系统的一个功能就是安排好处理器的使用权，也就是说，在每个时刻处理器分配给哪个程序使用是操作系统决定的。
		处理器管理最基本的功能是处理中断事件，配置了操作系统后，就可对各种事件进行处理。处理器管理还有一个功能就是处理器调度，针对不同情况采取不同的调度策略。
	存储管理
		计算机的内存中有成千上万个存储单元，都存放着程序和数据。何处存放哪个程序，何处存放哪个数据．都是由操作系统来统一安排与管理的o这是操作系统的存储功能。
		存储器管理主要是指针对内存储器的管理。主要任务是分配内存空间，保证各作业占用的存储空间不发生矛盾，并使各作业在自己所属存储区中不互相干扰。
	设备管理
		计算机系统中配有各种各样的外部设备。操作系统的设备管理功能采用统一管理模式，自动处理内存和设备间的数据传递，从而减轻用户为这些设备设计输入输出程序的负担。
		设备管理是指负责管理各类外围设备，包括分配、启动和故障处理等。主要任务是当用户使用外部设备时，必须提出要求，待操作系统进行统一分配后方可使用。
	作业管理
		作业是指独立的、要求计算机完成的一个任务。操作系统的作业管理功能包括两点尸是在多道程序运行IC现货商时，使得备用户合理地共享计算机系统资源
		是提供给操作人员一套控制命令用来控制程序的运行。
		每个用户请求计算机系统完成的一个独立的操作称为作业。作业管理包括作业的输入和输出，作业的调度与控制，这是根据用户的需要来控制作业运行的。
	文件管理
		计算机系统中的程序或数据都要存放在相应存储介质上。为了便于管理，操作系统招相关的信息集中在一起，称为文件。操作系统的文件管理功能就是负责这些文件的存储、检索、更新、保护和共享。
		文件管理是指操作系统对信息资源的管理。在操作系统中，将负责存取的管理信息的部分称为文件系统。文件管理支持文件的存储、检索和修改等操作以及文件的保护功能。
	操作系统的分类：
		（1）根据工作方式分为：批处理操作系统、分时操作系统、实时操作系统、网络操作系统和分布式操作系统等；

		（2）根据架构可以分为：单内核操作系统、多内核操作系统等；

		（3）根据运行的环境可以分为：桌面操作系统，嵌入式操作系统等；

		（4）根据指令的长度分为：8bit， 16bit， 32bit，64bit的操作系统。

19. 数据结构
		二叉树的优缺点

		八种排序
			时间复杂度       最差		最好		   状态            空间复杂度
			二叉树排序       O(n2)	O(n*log2n)	       不稳定	        O(n)
			冒泡排序	       O(n2)	O(n2)	       稳定	           O(1)
			堆排序   	O(n*log2n)	    O(n*log2n)	       不稳定          O(1)
			插入排序        O(n2)	    O(n2)	        稳定	        O(1)
			快速排序	       O(n2)	O(n*log2n)          	不稳定         	O(log2n)~O(n)
			选择排序         O(n2)	O(n2)          稳定 	       O(1)
			希尔排序	       O	    O	            不稳定	        O(1)

20. RPC的特点以及传输原理


21. java重载，重写，同样的方法的同样的参数，是否可以，

	java的优缺点

22. 单例模式，工厂模式

23. B+树的结构

24. 添加索引需要注意什么
	1，创建索引
		对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加

		索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下

		降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。


25. jdk1.8更新内容
	1.Lambda表达式
		lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码
	2.函数式接口

	3.*方法引用和构造器调用
	4.Stream API
	5.接口中的默认方法和静态方法
		在接口中可以使用default和static关键字来修饰接口中定义的普通方法
	6.新时间日期API

26. 怎么查看表锁死的方式
	mysql查看被锁住的表
	查询是否锁表
	show OPEN TABLES where In_use > 0;
	查看所有进程
	MySQL:
	show processlist;
	mariabd:
	 
	show full processlist;
	查询到相对应的进程===然后 kill id
	 
	杀掉指定mysql连接的进程号
	kill $pid
	查看正在锁的事务
	SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 
	查看等待锁的事务
	SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 
	查看innodb引擎的运行时信息
	show engine innodb status\G;
	查看造成死锁的sql语句，分析索引情况，然后优化sql语句；
	 
	查看服务器状态
	show status like '%lock%';
	查看超时时间：
27. 怎么理解的架构师
	系统架构师是一个既需要掌控整体又需要洞悉局部瓶颈并依据具体的业务场景给出解决方案的团队领导型人物。一个架构师得需要足够的想像力,能把各种目标需求进行不同维度的扩展，为目标客户提供更为全面的需求清单。架构师在软件开发的整个过程中起着很重要的作用

28. 怎么去接触，了解新的知识

29. 动态代理

30. 年轻代，年老代，永久代回收方法

31. 重载和重写

32. java的特性

33. MyBatis中#{}和${}的区别
	1、在MyBatis 的映射配置文件中，动态传递参数有两种方式：
		（1）#{} 占位符
		（2）${} 拼接符
	2、#{} 和 ${} 的区别
		（1）
			1）#{} 为参数占位符 ?，即sql 预编译
			2）${} 为字符串替换，即 sql 拼接
		（2）
			1）#{}：动态解析 -> 预编译 -> 执行
			2）${}：动态解析 -> 编译 -> 执行
		（3）
			1）#{} 的变量替换是在DBMS 中
			2）${} 的变量替换是在 DBMS 外
		（4）
			1）变量替换后，#{} 对应的变量自动加上单引号 ''
			2）变量替换后，${} 对应的变量不会加上单引号 ''
		（5）
			1）#{} 能防止sql 注入
			2）${} 不能防止sql 注入
	3、#{} 和 ${} 的实例：假设传入参数为 1
		（1）开始
			1）#{}：select * from t_user where uid=#{uid}
			2）${}：select * from t_user where uid= '${uid}'
		（2）然后
			1）#{}：select * from t_user where uid= ?
			2）${}：select * from t_user where uid= '1'
		（3）最后
			1）#{}：select * from t_user where uid= '1'
			2）${}：select * from t_user where uid= '1'
	4、#{} 和 ${} 的大括号中的值
		（1）单个参数的情形
			1）#{}
				无MyBatis 默认值，可任意，且与参数名无关


34. SimpleDateFormat线程不安全
	原来SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题,如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。单例、多线程、又有成员变量（这个变量在方法中是可以修改的），这个场景是不是很像servlet，在高并发的情况下，容易出现幻读成员变量的现象，故说SimpleDateFormat是线程不安全的对象。


分配内存
java中cas怎么实现
多线程只启动核心线程，拒绝策略
redis淘汰策略
redis的hash怎么扩容
redis的哨兵机制至少是三台机器
mysql的binlog日志 redo log
 全量复制和增量复制
 jstart用法
 liunx基本命令符
kafka为什么读写速度比较快
kafka数据丢失的情况
sleep()和wait的区别
wait
java多线程原子性
会不会有new一个内存直接分配老年代里面










