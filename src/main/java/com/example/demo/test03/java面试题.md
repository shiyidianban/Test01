### 一、关于Java虚拟机底层原理与性能优化
##### 1、Java虚拟机内存模型能说说吗？
java内存模型主要包括：虚拟机栈，堆，程序计数寄存器，本地方法栈，方法区

程序计数寄存器：

    程序计数器是一块较小的内存空间，可看作当前线程正在执行的字节码的行号指示器
    如果当前线程正在执行的是
    
    Java方法
    计数器记录的就是当前线程正在执行的字节码指令的地址
    
    本地方法
    那么程序计数器值为undefined
    
    一块较小的内存空间
    线程私有。每条线程都有一个独立的程序计数器。
    是唯一一个不会出现OOM的内存区域。
    生命周期随着线程的创建而创建，随着线程的结束而死亡。
    
虚拟机栈
    
    JVM中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的
    栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，
    就是栈帧从入栈到出栈的过程
    
    当前栈帧：局部变量表，操作栈，动态链接，方法返回地址

    Java虚拟机栈会出现两种异常
    
    StackOverFlowError
    若Java虚拟机栈的内存大小不允许动态扩展,那么当线程请求的栈深度大于虚拟机允许的最大深度时(但内存空间可能还有很多),就抛出此异常
    
    OutOfMemoryError
    若Java虚拟机栈的内存大小允许动态扩展,且当线程请求栈时内存用完了,无法再动态扩展了,此时抛出OutOfMemoryError异常
    Java虚拟机栈也是线程私有的,每个线程都有各自的Java虚拟机栈,而且随着线程的创建而创建,随着线程的死亡而死亡.
    
本地方法栈

    本地方法栈和Java虚拟机栈实现的功能与抛出异常几乎相同
    只不过虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务,本地方法区则为虚拟机使用到的Native方法服务.
    
    在JVM内存布局中，也是线程对象私有的,但是虚拟机栈“主内”，而本地方法栈“主外”
    这个“内外”是针对JVM来说的，本地方法栈为Native方法服务
    线程开始调用本地方法时，会进入一个不再受JVM约束的世界
    本地方法可以通过JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器,具有和JVM相同的能力和权限
    当大量本地方法出现时,势必会削弱JVM对系统的控制力,因为它的出错信息都比较黑盒.
    对于内存不足的情况，本地方法栈还是会拋出native heap OutOfMemory
    
Java堆

    Heap是OOM故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用
    通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间
    堆的内存空间既可以固定大小，也可运行时动态地调整，通过如下参数设定初始值和最大值，
    
    比如 -Xms256M. -Xmx1024M
    其中-X表示它是JVM运行参数
    ms是memorystart的简称 最小堆容量
    mx是memory max的简称 最大堆容量
    
    但是在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，
    所以在线上生产环境中，JVM的Xms和Xmx设置成一样大小，避免在GC后调整堆大小时带来的额外压力
    
    堆分成两大块:新生代和老年代
    对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象
    
    新生代= 1个Eden区+ 2个Survivor区
    绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发Young GC。
    垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。
    依然存活的对象会被移送到Survivor区，这个区真是名副其实的存在
    
    Survivor 区分为S0和S1两块内存空间，送到哪块空间呢?每次Young GC的时候，将存活的对象复制到未使用的那块空间，
    然后将当前正在使用的空间完全清除，交换两块空间的使用状态
    如果YGC要移送的对象大于Survivor区容量上限，则直接移交给老年代
    假如一些没有进取心的对象以为可以一直在新生代的Survivor区交换来交换去，那就错了。每个对象都有一个计数器，每次YGC都会加1。
    
    -XX:MaxTenuringThreshol
    
    参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升至老年代。如果该参数配置为1,那么从新生代的Eden区直接移至老年代。
    默认值是15，可以在Survivor 区交换14次之后，晋升至老年代
    
    若Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代中进行分配;
    如果老年代也无法放下，则会触发Full Garbage Collection(Full GC);
    如果依然无法放下，则抛OOM.
    
    堆出现OOM的概率是所有内存耗尽异常中最高的
    出错时的堆内信息对解决问题非常有帮助，所以给JVM设置运行参数-
    
    XX:+HeapDumpOnOutOfMemoryError
    让JVM遇到OOM异常时能输出堆内信息
    
    在不同的JVM实现及不同的回收机制中，堆内存的划分方式是不一样的
    
    存放所有的类实例及数组对象
    除了实例数据，还保存了对象的其他信息，如Mark Word（存储对象哈希码，GC标志，GC年龄，同步锁等信息），
    Klass Pointy(指向存储类型元数据的指针）及一些字节对齐补白的填充数据（若实例数据刚好满足8字节对齐，则可不存在补白）
    
方法区

    Java虚拟机规范中定义方法区是堆的一个逻辑部分,但是别名Non-Heap(非堆),以与Java堆区分.
    方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.

    线程共享
    方法区是堆的一个逻辑部分,因此和堆一样,都是线程共享的.整个虚拟机中只有一个方法区.
    永久代
    方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为永久代.
    
    内存回收效率低
    Java虚拟机规范对方法区的要求比较宽松,可以不实现垃圾收集.
    方法区中的信息一般需要长期存在,回收一遍内存之后可能只有少量信息无效.
    对方法区的内存回收的主要目标是:对常量池的回收和对类型的卸载
    和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。
    当方法区内存空间无法满足内存分配需求时,将抛出OutOfMemoryError异常.
    
运行时常量池

    运行时常量池是方法区的一部分.
    方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码.其中常量存储在运行时常量池中.
    
    在近三个JDK版本（6、7、8）中， 运行时常量池的所处区域一直在不断的变化，
    在JDK6时它是方法区的一部分
    7又把他放到了堆内存中
    8之后出现了元空间，它又回到了方法区。
    其实，这也说明了官方对“永久代”的优化从7就已经开始了
    
Metaspace (元空间)

    在JDK8，元空间的前身Perm区已经被淘汰,在JDK7及之前的版本中，只有Hotspot才有Perm区(永久代),它在启动时固定大小,很难进行调优,并且Full GC时会移动类元信息
    默认情况下，“元空间”的大小可以动态调整，或者使用新参数MaxMetaspaceSize来限制本地内存分配给类元数据的大小.
    在JDK8里，Perm 区所有内容中
    字符串常量移至堆内存
    其他内容包括类元信息、字段、静态属性、方法、常量等都移动至元空间
    
    元空间特色
    充分利用了Java语言规范：类及相关的元数据的生命周期与类加载器的一致
    每个类加载器都有它的内存区域-元空间
    只进行线性分配
    不会单独回收某个类（除了重定义类 RedefineClasses 或类加载失败）
    没有GC扫描或压缩
    元空间里的对象不会被转移
    如果GC发现某个类加载器不再存活，会对整个元空间进行集体回收

GC

    Full GC时，指向元数据指针都不用再扫描，减少了Full GC的时间
    很多复杂的元数据扫描的代码（尤其是CMS里面的那些）都删除了
    元空间只有少量的指针指向Java堆
    这包括：类的元数据中指向java.lang.Class实例的指针;数组类的元数据中，指向java.lang.Class集合的指针。
    没有元数据压缩的开销
    减少了GC Root的扫描（不再扫描虚拟机里面的已加载类的目录和其它的内部哈希表）
    G1回收器中，并发标记阶段完成后就可以进行类的卸载
    
JVM关闭
    
    正常关闭：当最后一个非守护线程结束或调用了System.exit或通过其他特定于平台的方式,比如ctrl+c。
    强制关闭：调用Runtime.halt方法，或在操作系统中直接kill（发送single信号）掉JVM进程。
    异常关闭：运行中遇到RuntimeException 异常等
    在某些情况下，我们需要在JVM关闭时做一些扫尾的工作，比如删除临时文件、停止日志服务。为此JVM提供了关闭钩子（shutdown hocks）来做这些事件。
    
    Runtime类封装java应用运行时的环境，每个java应用程序都有一个Runtime类实例，使用程序能与其运行环境相连。
    
    关闭钩子本质上是一个线程（也称为hock线程），可以通过Runtime的addshutdownhock （Thread hock）向主jvm注册一个关闭钩子。
    hock线程在jvm正常关闭时执行，强制关闭不执行。
    
    对于在jvm中注册的多个关闭钩子，他们会并发执行，jvm并不能保证他们的执行顺序。

##### 2、类加载器的双亲委派模型是什么？

一、预定义类型类加载器

    1、启动（Bootstrap）类加载器，负责将 <Java_Runtime_Home>/lib 下面的类库加载到内存中。
    2、扩展（Extension）类加载器ExtClassLoader：负责将 < Java_Runtime_Home >/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中
    3、系统（System）类加载器AppClassLoader：负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。
    4、线程上下文类加载器ThreadContextClassLoader（TCCL）：用于解决双亲委托模型的缺陷，可以实现核心库接口加载系统类（这一条先忽略）
    
    1、缓存路：查找自身加载器是否有缓存，没有则委托父类AppClassLoader加载器---->查找AppClassLoader加载器是否有缓存，没有则委托父类ExtClassLoader---->查找ExtClassLoader加载器是否有缓存,没有则委托BoopStrap加载器–>查找BoopStrap加载器是否有缓存，没有则开始加载（在任何一个加载器中该类已经加载，则直接返回）
    2、加载路：BoopStrap在核心库中加载，如果未加载成果---->ExtClassLoader在lib/ext中加载，如果未加载成果----->AppClassLoader在当前classpath中加载，如果未加载成果---->自定义加载器加载，如果未加载成果---->抛出异常ClassNotFoundException

##### 3、JVM垃圾收集算法与收集器有哪些？

    1.哪些对象可以回收的判定
        垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中那些还“活着”，哪些已经“死去”(即不可能再被任何途径使用的对象)。
    引用计数算法
        很多教科书判定对象存活的算法是这样的：给对象添加一个引用计数器，每当一个地方引用它时，计数器值就加1；
        当引用失效时，计数器值就减1，任何时刻计数器为0的对象就是不可能再被使用的。
        引用计数算法(Reference Counting)实现简单，判定效率高，一些著名的应用案例，
        例如：ActionScript3的FlashPlayer、Python语言等都使用了引用计数算法进行内存管理。
        但是，至少主流的Java虚拟机里面没有使用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
    可达性分析算法
        在主流的商用程序语言(Java、C#)的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。
        这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，
        当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
        在Java语言中，可作为GC Roots的对象包括下面几种：
        > 虚拟机栈(栈帧中的本地变量表)中引用的对象。
        > 方法区中类的静态属性引用的变量。
        > 方法区中常量引用的对象。
        > 本地方法栈JNI(即一般说的Native方法)引用的对象。 
        
    3>回收方法区
    永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。
    回收废弃常量和回收Java堆中的对象非常类似，判定一个类是否是“无用的类”的条件相对苛刻许多，类需要同时满足下面3个条件才能算是“无用的类”：
    >该类所有的实例都已被回收，也就是Java堆中不存在该类的任何实例。
    >加载该类的ClassLoader已经被回收。
    >该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    
    是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。
    
    在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP的场景都需要虚拟机具备类卸载的功能，
    以保证永久代不会溢出。
    
    2.垃圾收集算法
    1>标记-清除算法(Mark-Sweep)
    算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
    它的主要不足有两个：
    一个是效率问题，标记和清除两个过程的效率都不高；
    另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
    
    2>复制算法(Copying)
    为了解决效率问题，出现了复制算法，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。
    当一块的内存用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理到。
    这样每次都对整个半区进行内存回收，内存分配时也不用考虑内存碎片等情况。
    
    这种算法的代价是将内存缩小为了原来的一半。
    
    现在的商业的虚拟机都采用这收集算法来回收新生代。IBM公司的研究表明，新生代中的对象98%是“朝生夕死”的，
    所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，
    每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还活着的对象一次性地复制到另一块Survivor空间上，
    最后清理掉Eden和刚才用过的Survivor空间。
    HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
    如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

    3>标记-整理算法(Mark-Compact)
    复制收集算法在对象存活较高时就要进行较多的复制操作，效率将会降低。
    所以老年代一般不用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”算法。
    标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象就行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
    
    4>分代收集算法
    当前商业的虚拟机的垃圾回收都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代。这样就可以根据各个年代的特点采用最适合的收集算法。
    在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，
    只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外的空间对它
    进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。
    
    3.垃圾收集器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
    不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别。
    这里讨论的收集器基于JDK 1.7 Update14之后的HotSpot虚拟机。
    3.1 Serial收集器
    Serial收集器是最基本、发展历史最悠久的收集器，这个收集器是一个单线程的收集器，
    但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，
    更重要的是在它进行垃圾收集时，必须暂停其它所有的工作线程，直到它收集结束。Stop The World
    Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
    
    3.2 ParNew收集器
    ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括控制参数、回收策略等都和Serial收集器一样。
    ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，
    其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
    
    3.3 Parallel Scavenge收集器
    Parallel Scavenge收集器的关注点与其它收集器不同，Parallel Scavenge的目标是达到一个可控制的吞吐量。
    所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
    如果虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
    停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，
    而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
    {
    Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是
    控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。
    -XX:MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。把新生代调小一些，收集300MB新生代肯定比收集500MB快，这也导致垃圾收集发生的更频繁一些，原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒，停顿时间在下降，但吞吐量也下降了。
    -XX:GCTimeRatio参数的值应该是一个大于0小于100的整数，如值为m，花费在GC上的时间比例不超过1/(1+m）
    }
    Parallel Scavenge收集器还有一个参数-XX:UseAdaptiveSizePolicy，
    这是一个开关参数，打开后，
    就不需要手工指定新生代的大小(-Xmn)、Eden与Servivor区的比例(-XX:ServivorRatio)、
    晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数了，
    虚拟机会根据当前系统的运行情况收集性能监控信息，
    动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略。

    3.4 Serial Old收集器
    Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。
    这个收集器的主要意义也是在于给Client模式下的虚拟机使用。
    如果在Server模式下，那么它主要还有两大用途：
    一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，
    另一种用途就是作为CMS收集器的后备预备，在并发收集发生Concurrent Mode Failure时使用。
    3.5 Parallel Old收集器
    Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
    这个收集器是在JDK 1.6中才开始提供的。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

    3.6 CMS收集器
    CMS收集器是一种以获取{最短回收停顿时间}为目标的收集器。基于“标记-清除”算法实现。
    整个过程分为4个步骤：
    >初始标记(CMS initial mark)
    >并发标记(CMS concurrent mark)
    >重新标记(CMS remark)
    >并发清除(CMS concurrent sweep)
    初始标记、重新标记这两个步骤仍然需要“Stop The World”。
    初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；
    并发标记：就是进行GC Roots Tracing的过程；
    重新标记：则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，
    这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    
    5.垃圾收集器参数总结
    
    【垃圾收集器组合】
    UseSerialGC              虚拟机运行在Client模式下的默认值，使用Serial+Serial Old的收集器组合进行内存回收
    UseParNewGC      使用ParNew + Serial Old的收集器组合
    UserConcMarkSweepGC   使用ParNew + CMS + Serial Old组合，Serial Old作为CMS的后备收集器使用
    UserParallelGC    虚拟机运行在Server模式下的默认值，使用Parallel Scavege + Serial Old组合
    UserParallelOldGC            使用Parallel Scavege + Parallel Old组合
    
    【一些配置】
    SurvivorRatio          新生代中Eden区与Suivivor区的容量比值，默认为8，表示Eden:Suivivor = 8:1
    PretenureSizeThreshold  直接晋升到老年代的对象大小，大于这个参数的对象将直接在老年代分配
    MaxTenuringThreshold  晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC后，年龄就增加1，当超过这个值时就进入老年代
    UseAdaptiveSizePolicy     自适应的调节策略，动态调整Java堆中各个区域的大小以及进入老年代的年龄
    HandlePromotionFailure  是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况
    ParallelGCThreads          设置并行GC时进行内存回收的线程数
    
    【Parallel Scavenge时生效】
    MaxGCPauseMillis 设置GC的最大停顿时间。
    GCTimeRatio GC时间占总时间的比率，默认值为99，即允许1%的GC时间。
    
    【CMS时生效】
    CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发垃圾收集，默认为68%。
    UseCMSCompactAtFullCollection 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。
    CMSFullGCsBeforeCompaction 设置CMS收集器在进行多少次垃圾收集后进行一次内存碎片整理。
    
    https://blog.csdn.net/u010558660/article/details/53764124

##### 4、JVM诊断调优工具用过哪些？
    
    jdk自带的工具
        jconsole
    Jconsole（Java Monitoring and Management Console）是从java5开始，在JDK中自带的java监控和管理控制台，
    用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。
    jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。
    直接在jdk/bin目录下点击jconsole.exe即可启动
    
        VisualVM
    简介
    VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。
    VisualVM 对 Java Development Kit (JDK) 工具所检索的 JVM 软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java 应用程序的数据的方式提供该信息。
    您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。
    此外，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。
    VisualVM 是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。
    同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole 一样同样可以选择本地和远程，
    如果需要监控远程同样需要配置相关参数
    
    MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。
    使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，
    并可以通过报表直观的查看到可能造成这种结果的对象。
    
    GChisto
    GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。
    虽然界面略显粗糙，但是功能还是不错的。
    配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志
    
    gcviewer
    GCViewer也是一款分析小工具，用于可视化查看由Sun / Oracle, IBM, HP 和 BEA Java 虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示 的界面比较乱没有GChisto更专业一些。

##### 5、每秒几十万并发的秒杀系统为什么会频繁发生GC？
 
##### 6、日均百万级交易系统如何优化JVM？

    1.了解自己的业务目标
    2.计算每台机器实现的tps。
    3.每个tps需要的对象空间，计算每秒需要的空间。
    4.分析青年代，老年队GC需要的时间。承受的时间。
    5.根据承受能力，设置JVM参数。

### 二、关于Mysql索引数据结构与性能优化
##### 1、索引数据结构红黑树，Hash，B+树能说下吗？

    红黑树
    性质1：每个节点要么是黑色，要么是红色。
    性质2：根节点是黑色。
    性质3：每个叶子节点（NIL）是黑色。
    性质4：每个红色结点的两个子结点一定都是黑色。
    性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
    红黑树并不是一个完美平衡二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，
    但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。
    所以我们叫红黑树这种平衡为黑色完美平衡。
    
    Hash
    其原理是首先根据key值和哈希函数创建一个哈希表（散列表），燃耗根据键值，通过散列函数，定位数据元素位置。
    
    B树
    B树（Balance Tree）又叫做B- 树（其实B-是由B-tree翻译过来，所以B-树和B树是一个概念） ，
    它就是一种平衡多路查找树。
    1. 有一个根节点，根节点只有一个记录和两个孩子或者根节点为空；
    2. 每个节点记录中的key和指针相互间隔，指针指向孩子节点；
    3. d是表示树的宽度，除叶子节点之外，其它每个节点有[d/2,d-1]条记录，并且些记录中的key都是从左到右按大小排列的，有[d/2+1,d]个孩子；
    4. 在一个节点中，第n个子树中的所有key，小于这个节点中第n个key，大于第n-1个key，
    比如上图中B节点的第2个子节点E中的所有key都小于B中的第2个key 9，大于第1个key 3;
    5. 所有的叶子节点必须在同一层次，也就是它们具有相同的深度；
    
    B+树
    其实B-Tree有许多变种，其中最常见的是B+Tree，比如MySQL就普遍使用B+Tree实现其索引结构。B-Tree相比，B+Tree有以下不同点：
    每个节点的指针上限为2d而不是2d+1；
    内节点不存储data，只存储key；
    叶子节点不存储指针；

##### 2、千万级数据表如何用索引快速查找？

    实际上，常用来构建索引的数据结构，就是我们之前讲过的几种支持动态数据集合的数据结构。比如，散列表、红黑树、跳表、B+树。
    除此之外，位图、布隆过滤器可以作为辅助索引，有序数组可以用来对静态数据构建索引。
    
    我们知道，散列表增删改查操作的性能非常好，时间复杂度是O(1)。一些键值数据库，比如Redis、Memcache，就是使用散列表来构建索引的。
    这类索引，一般都构建在内存中。
    
    红黑树作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是O(logn)，也非常适合用来构建内存索引。
    Ext文件系统中，对磁盘块的索引，用的就是红黑树。
    
    B+ 树比起红黑树来说，更加适合构建存储在磁盘的索引。B+树是一个多叉树，
    所以，以相同个数的数据构建索引，B+树的高度要低于红黑树。当借助索引查询数据的时候，读取B+树索引，需要的磁盘IO次数更少。所以，大部分关系型数据库的索引，比如MySQL、Oracle，都是用B+树来实现的。
    
##### 3、如何基于索引B+树精准建立高性能索引？

    MySQL索引种类
    	普通索引：仅加速查询，
    	唯一索引：加速查询 + 列值唯一（可以有null），
    	组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，
    	主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个，
    	全文索引：对文本的内容进行分词，进行搜索，即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。
       MySQL索引种类：
       	Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。
       	1. FULLTEXT
    		即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。
    	2. HASH
    		由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
    	3. BTREE
    		BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
    	4. RTREE
    		RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找　

##### 4、联合索引底层数据结构又是怎样的？

    MyISAM索引实现（非聚集索引）
    MyISAM中索引和数据是分开储存的，并且主键索引和辅助索引（二级索引）的储存方式是一样的。
    
    InnoDB索引实现（聚集索引）
    InnoDB中索引文件和数据文件是同一个文件。并且主键索引和二级索引储存方式有所不同，如图所示，二级索引的叶子节点不储存数据，仅储存主键ID。
    
    联合索引
    比较相等时，先比较第一列的值，如果相等，再继续比较第二列，以此类推。
    
    最左前缀原理
    使用联合索引时，索引列的定义顺序将会影响到最终查询时索引的使用情况。
    例如联合索引（a,b,c），
    mysql会从最左边的列优先匹配，如果最左边的带头大哥没有使用到，在未使用覆盖索引的情况下，就只能全表扫描。
    联合底层数据结构思考，mysql会优先以联合索引第一列匹配，此后才会匹配下一列，如果不指定第一列匹配的值，也就无法得知下一步查询哪个节点。
    另外还有一种情况，如果遇到 > < between等这样的范围查询，那B+树中也就无法对下一列进行等值匹配了。

##### 5、覆盖索引与聚集索引到底是什么？

    聚集索引
    一张表里面只能有一个聚集索引，一般设置主键为索引。
    数据库中行数据的物理顺序和索引顺序相同。这样的索引称为聚集索引。
    一张表只有一个物理顺序，也就只能有一个聚集索引。
    
    覆盖索引（复合索引）
    定义：包含两个或多个属性列的索引称为复合索引。
    形象定义：复合索引的结构与电话簿类似，人名由姓和名构成，
    电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
    如果您知道姓，电话簿将非常有用；
    如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

##### 6、Mysql最左前缀优化原则是什么？

    注意事项
    范围查询
    mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。
    范围列可以用到索引，但是范围列后面的列无法用到索引。
    即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引
    
    like 语句的索引问题
    如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀
    在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描
    
    不要在列上进行运算
    如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描
    例如 select * from user where YEAR(birthday) < 1990
    可以改造成 select * from users where birthday <’1990-01-01′
    
    索引不会包含有 NULL值的列
    只要列中包含有 NULL 值都将不会被包含在索引中，
    复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。
    所以在数据库设计时不要让字段的默认值为 NULL
    
    尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(*)，
    表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，
    而一些状态、性别字段可能在大数据面前区分度就是 0。
    一般需要 join 的字段都要求区分度 0.1 以上，即平均 1 条扫描 10 条记录
    
    覆盖索引的好处
    如果一个索引包含所有需要的查询的字段的值，我们称之为覆盖索引。
    覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量
    
### 三、关于BIO，NIO，AIO，Netty及Redis线程模型

##### 1、BIO，NIO，AIO的区别？

    BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。
    NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。
    AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。
    
    BIO是一个连接一个线程。
    NIO是一个请求一个线程。
    AIO是一个有效请求一个线程。
    
    BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
    NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
    AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
    适用场景分析
    
    BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
    NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
    AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。
    
    BIO
    在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，
    然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，
    而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，
    如果有的话，客户端会线程会等待请求结束后才继续执行。
    
    NIO
    NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 
    在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。
    也就是说，将每一个客户端请求分配给一个线程来单独处理。
    这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。
    由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。
    如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。
    
    NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  
    也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。
    
    BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；
    而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。
    
    NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，
    所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，
    才开启一个线程进行处理，也就是一个请求一个线程模式。
    
    在NIO的处理方式中，当一个请求来的话，开启线程进行处理，
    可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。
    
    AIO
    
    与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。
    这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；
    对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  
    即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 
     在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：
     
     AsynchronousSocketChannel
     AsynchronousServerSocketChannel
     AsynchronousFileChannel
     AsynchronousDatagramChannel

##### 2、什么是阻塞IO以及非阻塞IO？

    区别:
    读:
    读本质来说其实不能是读,在实际中, 具体的接收数据不是由这些调用来进行，
    是由于系统底层自动完成的。read也好，recv也好只负责把数据从底层缓冲copy到我们指定的位置。
    
    在阻塞条件下，如果没有发现数据在网络缓冲中会一直等待，当发现有数据的时候会把数据读到用户指定的缓冲区。
    但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read并不会一直等待下去，而是立刻返回。
    read的原则是数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。
    所以一般情况下我们读取数据都需要采用循环读的方式读取数据，一次read完毕不能保证读到我们需要长度的数据，
    read完一次需要判断读到的数据长度再决定是否还需要再次读取。
    
    在非阻塞的情况下，read的行为是如果发现没有数据就直接返回，如果发现有数据那么也是采用有多少读多少的进行处理．
    对于读而言，阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回。
    recv中有一个MSG_WAITALL的参数　recv(sockfd, buff, buff_size, MSG_WAITALL)。
    在正常情况下　recv是会等待直到读取到buff_size长度的数据，但是这里的WAITALL也只是尽量读全，在有中断的情况下recv还是可能会被打断，
    造成没有读完指定的buff_size的长度。所以即使是采用recv + WAITALL参数还是要考虑是否需要循环读取的问题，
    在实验中对于多数情况下recv还是可以读完buff_size，所以相应的性能会比直接read进行循环读要好一些。
    不过要注意的是这个时候的sockfd必须是处于阻塞模式下，否则WAITALL不能起作用。
    
    写:
    写的本质也不是进行发送操作，而是把用户态的数据copy到系统底层去，然后再由系统进行发送操作，
    返回成功只表示数据已经copy到底层缓冲，而不表示数据以及发出,更不能表示对端已经接收到数据。
    
    在阻塞的情况，是会一直等待直到write完全部的数据再返回。
    这点行为上与读操作有所不同，究其原因主要是读数据的时候，
    通常刚开始我们并不知道要读的数据的长度，而是在数据的头部设置了一个长度，
    在读完指定长度的头部后，才知道整个要读的数据长度。
    如果一开始就贸然设置一个要读的数据长度，然后像阻塞的write那样去等读完，则很可能会造成死循环；
    而对于write，由于需要写的长度是已知的，所以可以一直再写，直到写完．
    不过问题是write是可能被打断造成write一次只write一部分数据，
    所以write的过程还是需要考虑循环write， 只不过多数情况下一次write调用就可能成功。
    　　
    
    非阻塞写的情况，是采用可以写多少就写多少的策略。
    与读不一样的地方在于，有多少读多少是由网络发送端是否有数据传输到本地内核缓存为准。
    但是对于可以写多少是由本地的网络堵塞情况为标准的，在网络阻塞严重的时候，
    网络层没有足够的内存来进行写操作，这时候就会出现写不成功的情况，阻塞情况下会尽可能(有可能被中断)等待到数据全部发送完毕，
    对于非阻塞的情况就是一次写多少算多少,没有中断的情况下也还是会出现write到一部分的情况。

##### 3、Reactor和Proactor IO设计模式是什么？

    同步I/O模型通常由Reactor模式实现，而异步I/O模型则由Proactor模式实现。
    
    Reactor模式又叫反应器或反应堆，即实现注册描述符（Handle）及事件的处理器（EventHandler），
    当有事件发生的时候，事件多路分发器（Event Demultiplexer）做出反应，
    调用事件具体的处理函数（ConcreteEventHandler::handle_event()）。
    
    Reator模式的典型启动过程如下：
    
    创建Reactor
    注册事件处理器（Reactor::register_handler()）
    调用事件多路分发器进入无限事件循环（Reacor:handle_events）
    当操作系统通知某描述符状态就绪时，事件多路分发器找出并调用此描述符注册的事件处理器。
    Reactor模式已经被广泛使用，著名的开源事件库libevent、libev、libuv都是使用Reactor模式。
    
    Reactor模式的优点：
    
    实现相对简单，对于耗时短的处理场景处理高效；
    操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；
    事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；
    事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来。
     
    Reactor模式的缺点：
    
    Reactor处理耗时长的操作（如文件I/O）会造成事件分发的阻塞，影响到后续事件的处理。
    因此涉及到文件I/O相关的操作，需要使用异步I/O，即使用Proactor模式效果更佳。
    
    Proactor模式又叫前摄器或主动器模式。它用于实现异步I/O模型，运行流程如下：
    
    　　1. Initiator主动调用Asynchronous Operation Processor发起异步I/O操作，
    
    　　2. 记录异步操作的参数和函数地址放入完成事件队列（Completion Event Queue）中
    
    　　3. Proactor循环检测异步事件是否完成。如果完成则从完成事件队列中取出回调函数完成回调。
    
    　　Boost库中的asio就使用了Proactor模式，其底层的异步I/O由操作系统提供，而异步事件的分发还是由epoll/kequeue/select等实现。
    
    两者区别
    
    　　综上我们可以发现Reactor模式和Proactor模式的主要区别:
    
    　　1. Reactor实现同步I/O多路分发，Proactor实现异步I/O分发。
    
    　　如果只是处理网络I/O单线程的Reactor尚可处理，但如果涉及到文件I/O，
       单线程的Reactor可能被文件I/O阻塞而导致其他事件无法被分发。
       所以涉及到文件I/O最好还是使用Proactor模式，或者用多线程模拟实现异步I/O的方式。
    
    　　2. Reactor模式注册的是文件描述符的就绪事件，而Proactor模式注册的是完成事件。
    
    　　即Reactor模式有事件发生的时候要判断是读事件还是写事件，
        然后用再调用系统调用(read/write等)将数据从内核中拷贝到用户数据区继续其他业务处理。
    
    　　而Proactor模式一般使用的是操作系统的异步I/O接口，
        发起异步调用（用户提供数据缓冲区）之后操作系统将在内核态完成I/O并拷贝数据到用户提供的缓冲区中，
        完成事件到达之后，用户只需要实现自己后续的业务处理即可。
    
    　　3. 主动和被动
    
    　　Reactor模式是一种被动的处理，即有事件发生时被动处理。而Proator模式则是主动发起异步调用，然后循环检测完成事件。
    
    　　最后我们知道linux系统提供的异步I/O，只支持O_DIRECT，不能带缓存。
        因此出现了开源库libeio，它和Linux的异步I/O一样也是用多线程模拟，但是更高效。
        下图是libeio的异步I/O实现，是不是很像Proactor模式啊。

##### 4、NIO底层select、poll和epoll实现的区别 ？

    I/O多路复用的三种形式
    
    select:知道了有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），
    我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
    所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长
    
    poll:本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的
    
    epoll(Linux内核所特有):可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。
    所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。
    （复杂度降低到了O(1)）(Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll)
    

##### 5、Java NIO的几个核心组成部分是什么？作用分别是什么？

    java内核的NIO的实现
    
    缓冲区Buffer
    
    缓冲区实际上是一个数组，封装了对数据结构化访问以及维护读写位置等信息
    
    在NIO库中，所有数据都是用缓冲区处理的，在读取数据时，直接读取到缓冲区。写入数据时，直接写入写缓冲区。任何时候访问NIO中的数据，都是 通过缓冲区进行操作
    
    最常用的的缓冲区是ByteBuffer。大部分Java基本类型都对应一种缓冲区
    
    通道channel
    
    Channel 是一个通道，可以通过它读取和写入数据。InputStream和OutputStream各自只能在一个方向上操作
    
    Channel是全双工的，所以它可以比流更好地映射底层的api
    
    多路复用器Selector
    
    Selector是NIO的编程基础。多路复用器提供选择已经就绪的任务的能力
    
    Selector会不断轮询注册在其上的Channel，如果channel上面有了新的TCP连接、读取或者写事件，
    这个channel就是就绪状态，会被Selector轮询出来。然后通过SelectionKey集合可以获取就绪的Channel集合，进行IO操作
    
    一个Selector可以同时轮询多个Channel，由于JDK使用了epoll（）代替传统的select实现，
    所以没有最大连接句柄1024/2048的限制。这意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端

##### 6、Redis、Netty、Tomcat的线程模型与NIO的联系是什么？
