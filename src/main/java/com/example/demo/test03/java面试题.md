### 一、关于Java虚拟机底层原理与性能优化
##### 1、Java虚拟机内存模型能说说吗？
java内存模型主要包括：虚拟机栈，堆，程序计数寄存器，本地方法栈，方法区

程序计数寄存器：

    程序计数器是一块较小的内存空间，可看作当前线程正在执行的字节码的行号指示器
    如果当前线程正在执行的是
    
    Java方法
    计数器记录的就是当前线程正在执行的字节码指令的地址
    
    本地方法
    那么程序计数器值为undefined
    
    一块较小的内存空间
    线程私有。每条线程都有一个独立的程序计数器。
    是唯一一个不会出现OOM的内存区域。
    生命周期随着线程的创建而创建，随着线程的结束而死亡。
    
虚拟机栈
    
    JVM中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的
    栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，
    就是栈帧从入栈到出栈的过程
    
    当前栈帧：局部变量表，操作栈，动态链接，方法返回地址

    Java虚拟机栈会出现两种异常
    
    StackOverFlowError
    若Java虚拟机栈的内存大小不允许动态扩展,那么当线程请求的栈深度大于虚拟机允许的最大深度时(但内存空间可能还有很多),就抛出此异常
    
    OutOfMemoryError
    若Java虚拟机栈的内存大小允许动态扩展,且当线程请求栈时内存用完了,无法再动态扩展了,此时抛出OutOfMemoryError异常
    Java虚拟机栈也是线程私有的,每个线程都有各自的Java虚拟机栈,而且随着线程的创建而创建,随着线程的死亡而死亡.
    
本地方法栈

    本地方法栈和Java虚拟机栈实现的功能与抛出异常几乎相同
    只不过虚拟机栈是为虚拟机执行Java方法(也就是字节码)服务,本地方法区则为虚拟机使用到的Native方法服务.
    
    在JVM内存布局中，也是线程对象私有的,但是虚拟机栈“主内”，而本地方法栈“主外”
    这个“内外”是针对JVM来说的，本地方法栈为Native方法服务
    线程开始调用本地方法时，会进入一个不再受JVM约束的世界
    本地方法可以通过JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器,具有和JVM相同的能力和权限
    当大量本地方法出现时,势必会削弱JVM对系统的控制力,因为它的出错信息都比较黑盒.
    对于内存不足的情况，本地方法栈还是会拋出native heap OutOfMemory
    
Java堆

    Heap是OOM故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用
    通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间
    堆的内存空间既可以固定大小，也可运行时动态地调整，通过如下参数设定初始值和最大值，
    
    比如 -Xms256M. -Xmx1024M
    其中-X表示它是JVM运行参数
    ms是memorystart的简称 最小堆容量
    mx是memory max的简称 最大堆容量
    
    但是在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，
    所以在线上生产环境中，JVM的Xms和Xmx设置成一样大小，避免在GC后调整堆大小时带来的额外压力
    
    堆分成两大块:新生代和老年代
    对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象
    
    新生代= 1个Eden区+ 2个Survivor区
    绝大部分对象在Eden区生成，当Eden区装填满的时候，会触发Young GC。
    垃圾回收的时候，在Eden区实现清除策略，没有被引用的对象则直接回收。
    依然存活的对象会被移送到Survivor区，这个区真是名副其实的存在
    
    Survivor 区分为S0和S1两块内存空间，送到哪块空间呢?每次Young GC的时候，将存活的对象复制到未使用的那块空间，
    然后将当前正在使用的空间完全清除，交换两块空间的使用状态
    如果YGC要移送的对象大于Survivor区容量上限，则直接移交给老年代
    假如一些没有进取心的对象以为可以一直在新生代的Survivor区交换来交换去，那就错了。每个对象都有一个计数器，每次YGC都会加1。
    
    -XX:MaxTenuringThreshol
    
    参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升至老年代。如果该参数配置为1,那么从新生代的Eden区直接移至老年代。
    默认值是15，可以在Survivor 区交换14次之后，晋升至老年代
    
    若Survivor区无法放下，或者超大对象的阈值超过上限，则尝试在老年代中进行分配;
    如果老年代也无法放下，则会触发Full Garbage Collection(Full GC);
    如果依然无法放下，则抛OOM.
    
    堆出现OOM的概率是所有内存耗尽异常中最高的
    出错时的堆内信息对解决问题非常有帮助，所以给JVM设置运行参数-
    
    XX:+HeapDumpOnOutOfMemoryError
    让JVM遇到OOM异常时能输出堆内信息
    
    在不同的JVM实现及不同的回收机制中，堆内存的划分方式是不一样的
    
    存放所有的类实例及数组对象
    除了实例数据，还保存了对象的其他信息，如Mark Word（存储对象哈希码，GC标志，GC年龄，同步锁等信息），
    Klass Pointy(指向存储类型元数据的指针）及一些字节对齐补白的填充数据（若实例数据刚好满足8字节对齐，则可不存在补白）
    
方法区

    Java虚拟机规范中定义方法区是堆的一个逻辑部分,但是别名Non-Heap(非堆),以与Java堆区分.
    方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.

    线程共享
    方法区是堆的一个逻辑部分,因此和堆一样,都是线程共享的.整个虚拟机中只有一个方法区.
    永久代
    方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为永久代.
    
    内存回收效率低
    Java虚拟机规范对方法区的要求比较宽松,可以不实现垃圾收集.
    方法区中的信息一般需要长期存在,回收一遍内存之后可能只有少量信息无效.
    对方法区的内存回收的主要目标是:对常量池的回收和对类型的卸载
    和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。
    当方法区内存空间无法满足内存分配需求时,将抛出OutOfMemoryError异常.
    
运行时常量池

    运行时常量池是方法区的一部分.
    方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码.其中常量存储在运行时常量池中.
    
    在近三个JDK版本（6、7、8）中， 运行时常量池的所处区域一直在不断的变化，
    在JDK6时它是方法区的一部分
    7又把他放到了堆内存中
    8之后出现了元空间，它又回到了方法区。
    其实，这也说明了官方对“永久代”的优化从7就已经开始了
    
Metaspace (元空间)

    在JDK8，元空间的前身Perm区已经被淘汰,在JDK7及之前的版本中，只有Hotspot才有Perm区(永久代),它在启动时固定大小,很难进行调优,并且Full GC时会移动类元信息
    默认情况下，“元空间”的大小可以动态调整，或者使用新参数MaxMetaspaceSize来限制本地内存分配给类元数据的大小.
    在JDK8里，Perm 区所有内容中
    字符串常量移至堆内存
    其他内容包括类元信息、字段、静态属性、方法、常量等都移动至元空间
    
    元空间特色
    充分利用了Java语言规范：类及相关的元数据的生命周期与类加载器的一致
    每个类加载器都有它的内存区域-元空间
    只进行线性分配
    不会单独回收某个类（除了重定义类 RedefineClasses 或类加载失败）
    没有GC扫描或压缩
    元空间里的对象不会被转移
    如果GC发现某个类加载器不再存活，会对整个元空间进行集体回收

GC

    Full GC时，指向元数据指针都不用再扫描，减少了Full GC的时间
    很多复杂的元数据扫描的代码（尤其是CMS里面的那些）都删除了
    元空间只有少量的指针指向Java堆
    这包括：类的元数据中指向java.lang.Class实例的指针;数组类的元数据中，指向java.lang.Class集合的指针。
    没有元数据压缩的开销
    减少了GC Root的扫描（不再扫描虚拟机里面的已加载类的目录和其它的内部哈希表）
    G1回收器中，并发标记阶段完成后就可以进行类的卸载
    
JVM关闭
    
    正常关闭：当最后一个非守护线程结束或调用了System.exit或通过其他特定于平台的方式,比如ctrl+c。
    强制关闭：调用Runtime.halt方法，或在操作系统中直接kill（发送single信号）掉JVM进程。
    异常关闭：运行中遇到RuntimeException 异常等
    在某些情况下，我们需要在JVM关闭时做一些扫尾的工作，比如删除临时文件、停止日志服务。为此JVM提供了关闭钩子（shutdown hocks）来做这些事件。
    
    Runtime类封装java应用运行时的环境，每个java应用程序都有一个Runtime类实例，使用程序能与其运行环境相连。
    
    关闭钩子本质上是一个线程（也称为hock线程），可以通过Runtime的addshutdownhock （Thread hock）向主jvm注册一个关闭钩子。
    hock线程在jvm正常关闭时执行，强制关闭不执行。
    
    对于在jvm中注册的多个关闭钩子，他们会并发执行，jvm并不能保证他们的执行顺序。

##### 2、类加载器的双亲委派模型是什么？

一、预定义类型类加载器

    1、启动（Bootstrap）类加载器，负责将 <Java_Runtime_Home>/lib 下面的类库加载到内存中。
    2、扩展（Extension）类加载器ExtClassLoader：负责将 < Java_Runtime_Home >/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中
    3、系统（System）类加载器AppClassLoader：负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。
    4、线程上下文类加载器ThreadContextClassLoader（TCCL）：用于解决双亲委托模型的缺陷，可以实现核心库接口加载系统类（这一条先忽略）
    
    1、缓存路：查找自身加载器是否有缓存，没有则委托父类AppClassLoader加载器---->查找AppClassLoader加载器是否有缓存，没有则委托父类ExtClassLoader---->查找ExtClassLoader加载器是否有缓存,没有则委托BoopStrap加载器–>查找BoopStrap加载器是否有缓存，没有则开始加载（在任何一个加载器中该类已经加载，则直接返回）
    2、加载路：BoopStrap在核心库中加载，如果未加载成果---->ExtClassLoader在lib/ext中加载，如果未加载成果----->AppClassLoader在当前classpath中加载，如果未加载成果---->自定义加载器加载，如果未加载成果---->抛出异常ClassNotFoundException

##### 3、JVM垃圾收集算法与收集器有哪些？

    1.哪些对象可以回收的判定
        垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中那些还“活着”，哪些已经“死去”(即不可能再被任何途径使用的对象)。
    引用计数算法
        很多教科书判定对象存活的算法是这样的：给对象添加一个引用计数器，每当一个地方引用它时，计数器值就加1；
        当引用失效时，计数器值就减1，任何时刻计数器为0的对象就是不可能再被使用的。
        引用计数算法(Reference Counting)实现简单，判定效率高，一些著名的应用案例，
        例如：ActionScript3的FlashPlayer、Python语言等都使用了引用计数算法进行内存管理。
        但是，至少主流的Java虚拟机里面没有使用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
    可达性分析算法
        在主流的商用程序语言(Java、C#)的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。
        这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，
        当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
        在Java语言中，可作为GC Roots的对象包括下面几种：
        > 虚拟机栈(栈帧中的本地变量表)中引用的对象。
        > 方法区中类的静态属性引用的变量。
        > 方法区中常量引用的对象。
        > 本地方法栈JNI(即一般说的Native方法)引用的对象。 
        
    3>回收方法区
    永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。
    回收废弃常量和回收Java堆中的对象非常类似，判定一个类是否是“无用的类”的条件相对苛刻许多，类需要同时满足下面3个条件才能算是“无用的类”：
    >该类所有的实例都已被回收，也就是Java堆中不存在该类的任何实例。
    >加载该类的ClassLoader已经被回收。
    >该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    
    是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。
    
    在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP的场景都需要虚拟机具备类卸载的功能，
    以保证永久代不会溢出。
    
    2.垃圾收集算法
    1>标记-清除算法(Mark-Sweep)
    算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
    它的主要不足有两个：
    一个是效率问题，标记和清除两个过程的效率都不高；
    另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
    
    2>复制算法(Copying)
    为了解决效率问题，出现了复制算法，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。
    当一块的内存用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理到。
    这样每次都对整个半区进行内存回收，内存分配时也不用考虑内存碎片等情况。
    
    这种算法的代价是将内存缩小为了原来的一半。
    
    现在的商业的虚拟机都采用这收集算法来回收新生代。IBM公司的研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
    HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
    如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

    3>标记-整理算法(Mark-Compact)
    复制收集算法在对象存活较高时就要进行较多的复制操作，效率将会降低。
    所以老年代一般不用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”算法。
    标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象就行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
    
    4>分代收集算法
    当前商业的虚拟机的垃圾回收都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代。这样就可以根据各个年代的特点采用最适合的收集算法。
    在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，
    只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外的空间对它
    进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。
    
    3.垃圾收集器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
    不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别。
    这里讨论的收集器基于JDK 1.7 Update14之后的HotSpot虚拟机。
    3.1 Serial收集器
    Serial收集器是最基本、发展历史最悠久的收集器，这个收集器是一个单线程的收集器，
    但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，
    更重要的是在它进行垃圾收集时，必须暂停其它所有的工作线程，直到它收集结束。Stop The World
    Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
    
    3.2 ParNew收集器
    ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括控制参数、回收策略等都和Serial收集器一样。
    ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
    https://blog.csdn.net/u010558660/article/details/53764124

##### 4、JVM诊断调优工具用过哪些？

##### 5、每秒几十万并发的秒杀系统为什么会频繁发生GC？
 
##### 6、日均百万级交易系统如何优化JVM？

### 二、关于Mysql索引数据结构与性能优化
##### 1、索引数据结构红黑树，Hash，B+树能说下吗？

##### 2、千万级数据表如何用索引快速查找？

##### 3、如何基于索引B+树精准建立高性能索引？

##### 4、联合索引底层数据结构又是怎样的？

##### 5、覆盖索引与聚集索引到底是什么？

##### 6、Mysql最左前缀优化原则是什么？

### 三、关于BIO，NIO，AIO，Netty及Redis线程模型

##### 1、BIO，NIO，AIO的区别？

##### 2、什么是阻塞IO以及非阻塞IO？

##### 3、Reactor和Proactor IO设计模式是什么？

##### 4、NIO底层select、poll和epoll实现的区别 ？

##### 5、Java NIO的几个核心组成部分是什么？作用分别是什么？

##### 6、Redis、Netty、Tomcat的线程模型与NIO的联系是什么？
