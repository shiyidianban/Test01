# Java

## 3.关键字

1. Java里面的final关键字是怎么用的？
        
        考察点：关键字
        
        参考回答：
        当用final修饰一个类时，表明这个类不能被继承。
        也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。
        final类中的成员变量可以根据需要设为final，
        但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
        
        “使用final方法的原因有两个。
        第一个原因是把方法锁定，以防任何继承类修改它的含义；
        第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。
        但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。
        在最近的Java版本中，不需要使用final方法进行这些优化了。“
        
        对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；
        如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
        
2. 关于Synchronized和lock
        
        考察点：java关键字
        
        参考回答：
        synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，
        能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
            1. 自旋锁
                所谓自旋锁，就是让某线程进入已被其它线程占用的同步代码时等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。
                这里等待的方式就是执行一段无意义的循环。
                如果锁长时间被占用，则浪费处理器资源，因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，
                就应当使用传统的方式去挂起线程了（默认10次）。
                   JDK1.6中 -XX:+UseSpinning 开启
                   JDK1.7中，去掉此参数，改为内置实现
                自旋适应锁
                JDK1.6引入自适应的自旋锁：自旋时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
                如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，
                进而它将允许自旋等待持续相对更长的时间。
                
            2. 锁粗化
                
            3. 轻量级锁
                轻量级锁并不是用来代替重量级锁（传统锁机制，如互斥等）的，目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
                轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
                如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，
                因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

            4. 偏向锁
                大部分情况是没有竞争的，所以可以通过偏向来提高性能
                                
                所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程（也就是说，这个线程已经占有这个锁，
                当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，
                因此这方面他是会对性能有所提升的，因为在大部分情况下是没有竞争的，所以锁此时是没用的，所以使用偏向锁是可以提高性能的）
                
                在使用偏向锁的时候会将对象头Mark的标记设置为偏向，并将拿到锁的线程的ID写入对象头Mark，这样就可以很快识别出这个线程是否拿到的锁。
                只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步（这段时间就省下来了）
                当其他线程请求相同的锁时，偏向模式结束
                在竞争激烈的场合，偏向锁会增加系统负担。
                
                偏向锁的开启
                使用偏向锁。
                方式一执行：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
                
                BiasedLockingStartupDelay=0设置偏向锁的启动时间，为零0，则是在系统启动时就启用偏向锁，
                但一般在系统启动时竞争是非常大的，使用它是非常耗时的，这里案例因为代码执行会很短，为了测试效果，在运行程度时，就启动偏向锁，所以置为0.
                
                不使用偏向锁
                方式二：-XX:-UseBiasedLocking
                
                取消偏向锁 -XX:-UseBiasedLocking
                                
        
        Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
        synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
        而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
        Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
        通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
        
3. volatile
    
        考察点：java关键字
        参考回答：
        volatile关键字是用来保证有序性和可见性的。
        这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，
        编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引
        起流水阻塞，比如数据相关性，提高CPU的执行效率。
        需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，
        所以有happens-before规则，其中有条就是volatile变量规则：
        对一个变量的写操作先行发生于后面对这个变量的读操作；
        有序性实现的是通过插入内存屏障来保证的。
        可见性：首先Java内存模型分为，主内存，工作内存。
        比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。
        加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。
        Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。

4. Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？

        考点：java关键字
        参考回答：
        synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。
        synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁