# Java

## 4.面向对象(一)

#####1. 若对一个类不重写，它的equals()方法是如何比较的？
        
        考点：基础
        
        参考回答：
        比较是对象的地址。
        
#####2. hashCode()和equals()方法有什么联系
        
        考察点：java关键字
        
        参考回答：
        synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，
        能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
            1. 自旋锁
                所谓自旋锁，就是让某线程进入已被其它线程占用的同步代码时等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。
                这里等待的方式就是执行一段无意义的循环。
                如果锁长时间被占用，则浪费处理器资源，因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，
                就应当使用传统的方式去挂起线程了（默认10次）。
                   JDK1.6中 -XX:+UseSpinning 开启
                   JDK1.7中，去掉此参数，改为内置实现
                自旋适应锁
                JDK1.6引入自适应的自旋锁：自旋时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
                如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，
                进而它将允许自旋等待持续相对更长的时间。
                
            2. 锁粗化
                
            3. 轻量级锁
                轻量级锁并不是用来代替重量级锁（传统锁机制，如互斥等）的，目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
                轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
                如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，
                因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

            4. 偏向锁
                大部分情况是没有竞争的，所以可以通过偏向来提高性能
                                
                所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程（也就是说，这个线程已经占有这个锁，
                当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，
                因此这方面他是会对性能有所提升的，因为在大部分情况下是没有竞争的，所以锁此时是没用的，所以使用偏向锁是可以提高性能的）
                
                在使用偏向锁的时候会将对象头Mark的标记设置为偏向，并将拿到锁的线程的ID写入对象头Mark，这样就可以很快识别出这个线程是否拿到的锁。
                只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步（这段时间就省下来了）
                当其他线程请求相同的锁时，偏向模式结束
                在竞争激烈的场合，偏向锁会增加系统负担。
                
                偏向锁的开启
                使用偏向锁。
                方式一执行：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
                
                BiasedLockingStartupDelay=0设置偏向锁的启动时间，为零0，则是在系统启动时就启用偏向锁，
                但一般在系统启动时竞争是非常大的，使用它是非常耗时的，这里案例因为代码执行会很短，为了测试效果，在运行程度时，就启动偏向锁，所以置为0.
                
                不使用偏向锁
                方式二：-XX:-UseBiasedLocking
                
                取消偏向锁 -XX:-UseBiasedLocking
                                
        
        Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
        synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
        而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
        Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
        通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
        
#####3. volatile
    
        考察点：java关键字
        参考回答：
        volatile关键字是用来保证有序性和可见性的。
        这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，
        编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引
        起流水阻塞，比如数据相关性，提高CPU的执行效率。
        需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，
        所以有happens-before规则，其中有条就是volatile变量规则：
        对一个变量的写操作先行发生于后面对这个变量的读操作；
        有序性实现的是通过插入内存屏障来保证的。
        可见性：首先Java内存模型分为，主内存，工作内存。
        比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。
        加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。
        Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。

4#####. Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？

        考点：java关键字
        参考回答：
        synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。
        synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁
        
#####5. Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
        
        考察点：JAVA构造函数
        
        参考回答：
        当新对象被创建的时候，构造函数会被调用。
        每一个类都有构造函数。
        在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
        Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
        Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。
        
#####6. Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
        
        考察点：方法
        
        参考回答：
        Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。
        与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
        
#####7. 面向对象的特征与“六原则一法则”

    面向对象的特征
    
        主要有抽象、继承、封装和多态四个方面，下面是我们来详细分析它们的含义：
        - 抽象：
        抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么
        
        - 继承：
        继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
        
        - 封装：
        通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
        面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。
        我们在类中编写的方法就是对实现细节的一种封装；
        我们编写一个类就是对数据和数据操作的封装。
        可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。 
        
        - 多态性：
        多态性是指允许不同子类型的对象对同一消息作出不同的响应。
        简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。
        多态性分为编译时的多态性和运行时的多态性。
        如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：
        当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，
        但一切对A系统来说都是透明的
        （就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，
        甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，
        但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。
        方法重载（overload）实现的是编译时的多态性（也称为前绑定），
        而方法重写（override）实现的是运行时的多态性（也称为后绑定）。
        
         运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
        
        1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
        
        2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。
        
    面向对象的“六原则一法则”：
    
        单一职责原则：一个类只做它该做的事情。
        开闭原则：软件实体应当对扩展开放，对修改关闭。
        依赖倒转原则：面向接口编程。
        里氏替换原则：任何时候都可以用子类型替换掉父类型。
        接口隔离原则：接口要小而专，绝不能大而全。
        合成聚合复用原则：优先使用聚合或合成关系复用代码。 
        迪米特法则：最少知识原则，一个对象应当对其他对象尽可能少的了解。
        
#####8.如何通过反射获取和设置对象私有字段的值？

        考察点：类
        
        参考回答：
        可以通过类对象的getDeclaredField()方法字段（Field）对象，
        然后再通过字段对象的setAccessible(true)将其设置为可以访问，
        接下来就可以通过get/set方法来获取/设置字段的值了。
        下面的代码实现了一个反射的工具类，
        其中的两个静态方法分别用于获取和设置私有字段的值，
        字段可以是基本类型也可以是对象类型且支持多级对象操作，
        例如ReflectionUtil.get(dog, "owner.car.engine.id");
        可以获得dog对象的主人的汽车的引擎的ID号。 
```java
import java.lang.reflect.Method;
class MethodInvokeTest {
    public static void main(String[] args) throws Exception {
        String str = "hello";
    Method m = str.getClass().getMethod("toUpperCase");
        System.out.println(m.invoke(str));  // HELLO
    }
}
```        
            
#####9. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？

    考察点：java重载
    
    参考回答：
    方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
    重载发生在一个类中，同名的方法如果有不同的参数列表
    （参数类型不同、参数个数不同或者二者都不同）则视为重载；
    重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，
    比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。
    重载对返回类型没有特殊的要求。
    
#####10. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确?

    考察点：对象
    
    参考回答：
    不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。
    Java对于eqauls方法和hashCode方法是这样规定的：
    (1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；
    (2)如果两个对象的hashCode相同，它们并不一定相同。
    当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，
    相同的对象可以出现在Set集合中，
    同时增加新元素的效率会大大下降
    （对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

#####11. 内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？

     考察点：类
     
     参考回答：
     一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是static的，
     那么它可以访问创建它的外部类对象的所有属性内部类如果是sattic的，
     即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，
     而内部类可以实现static，protected，private等访问修饰。
     当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，
     每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。
     
#####12.JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？
      
     考察点：异常
     
     参考回答：
     Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。
     在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。
     当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。
     Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。
     一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。
     用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。
     throws用来标明一个成员函数可能抛出的各种”异常”。
     Finally为确保一段代码不管发生什么”异常”都被执行一段代码。
     可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。
     每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。
     如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。           