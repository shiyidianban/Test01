# Java

## 4.面向对象(一)

1. 若对一个类不重写，它的equals()方法是如何比较的？
        
        考点：基础
        
        参考回答：
        比较是对象的地址。
        
2. hashCode()和equals()方法有什么联系
        
        考察点：java关键字
        
        参考回答：
        synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，
        能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
            1. 自旋锁
                所谓自旋锁，就是让某线程进入已被其它线程占用的同步代码时等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。
                这里等待的方式就是执行一段无意义的循环。
                如果锁长时间被占用，则浪费处理器资源，因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，
                就应当使用传统的方式去挂起线程了（默认10次）。
                   JDK1.6中 -XX:+UseSpinning 开启
                   JDK1.7中，去掉此参数，改为内置实现
                自旋适应锁
                JDK1.6引入自适应的自旋锁：自旋时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
                如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，
                进而它将允许自旋等待持续相对更长的时间。
                
            2. 锁粗化
                
            3. 轻量级锁
                轻量级锁并不是用来代替重量级锁（传统锁机制，如互斥等）的，目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
                轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
                如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，
                因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

            4. 偏向锁
                大部分情况是没有竞争的，所以可以通过偏向来提高性能
                                
                所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程（也就是说，这个线程已经占有这个锁，
                当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，
                因此这方面他是会对性能有所提升的，因为在大部分情况下是没有竞争的，所以锁此时是没用的，所以使用偏向锁是可以提高性能的）
                
                在使用偏向锁的时候会将对象头Mark的标记设置为偏向，并将拿到锁的线程的ID写入对象头Mark，这样就可以很快识别出这个线程是否拿到的锁。
                只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步（这段时间就省下来了）
                当其他线程请求相同的锁时，偏向模式结束
                在竞争激烈的场合，偏向锁会增加系统负担。
                
                偏向锁的开启
                使用偏向锁。
                方式一执行：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
                
                BiasedLockingStartupDelay=0设置偏向锁的启动时间，为零0，则是在系统启动时就启用偏向锁，
                但一般在系统启动时竞争是非常大的，使用它是非常耗时的，这里案例因为代码执行会很短，为了测试效果，在运行程度时，就启动偏向锁，所以置为0.
                
                不使用偏向锁
                方式二：-XX:-UseBiasedLocking
                
                取消偏向锁 -XX:-UseBiasedLocking
                                
        
        Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
        synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
        而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
        Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
        通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
        
3. volatile
    
        考察点：java关键字
        参考回答：
        volatile关键字是用来保证有序性和可见性的。
        这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，
        编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引
        起流水阻塞，比如数据相关性，提高CPU的执行效率。
        需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，
        所以有happens-before规则，其中有条就是volatile变量规则：
        对一个变量的写操作先行发生于后面对这个变量的读操作；
        有序性实现的是通过插入内存屏障来保证的。
        可见性：首先Java内存模型分为，主内存，工作内存。
        比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。
        加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。
        Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。

4. Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？

        考点：java关键字
        参考回答：
        synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。
        synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁
        
5. Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
        
        考察点：JAVA构造函数
        
        参考回答：
        当新对象被创建的时候，构造函数会被调用。
        每一个类都有构造函数。
        在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
        Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
        Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。
        
6. Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
        
        考察点：方法
        
        参考回答：
        Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。
        与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
        
7. 面向对象的特征与“六原则一法则”

    面向对象的特征
    
        主要有抽象、继承、封装和多态四个方面，下面是我们来详细分析它们的含义：
        - 抽象：
        抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么
        
        - 继承：
        继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。
        
        - 封装：
        通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
        面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。
        我们在类中编写的方法就是对实现细节的一种封装；
        我们编写一个类就是对数据和数据操作的封装。
        可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。 
        
        - 多态性：
        多态性是指允许不同子类型的对象对同一消息作出不同的响应。
        简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。
        多态性分为编译时的多态性和运行时的多态性。
        如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：
        当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，
        但一切对A系统来说都是透明的
        （就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，
        甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，
        但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。
        方法重载（overload）实现的是编译时的多态性（也称为前绑定），
        而方法重写（override）实现的是运行时的多态性（也称为后绑定）。
        
         运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
        
        1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
        
        2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。
        
    面向对象的“六原则一法则”：
    
        单一职责原则：一个类只做它该做的事情。
        开闭原则：软件实体应当对扩展开放，对修改关闭。
        依赖倒转原则：面向接口编程。
        里氏替换原则：任何时候都可以用子类型替换掉父类型。
        接口隔离原则：接口要小而专，绝不能大而全。
        合成聚合复用原则：优先使用聚合或合成关系复用代码。 
        迪米特法则：
        
        优先使用聚合或合成关系复用代码。
        
8. 
        