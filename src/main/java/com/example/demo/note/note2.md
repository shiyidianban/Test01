分布式业务，分布式存储，你觉得分布式的话会遇到那些问题
消息中间件产品，优缺点介绍
消息中间件如何保证消息的一致性和如果进行消息的重试机制
redis为什么这么快，redis采用多线程会出现什么问题
redis分布式操作的原子性，redis内部是如何实现的
SpringCloud对比下Dubbo什么场景该使用SpringCloud

锁机制介绍：行锁，表锁，排它锁，共享锁
乐观锁的业务场景以及实现方式
分布式事物的理解：常见的解决方案有哪些，什么是两阶段提交，三阶段式提交

ThreadLocal，volatile的实现原理和使用场景
ThreadLocal在什么场景下会出现OOM的情况，为什么
volatile，synchronized区别
synchronized锁粒度，模拟死锁场景
原子性和可见性
分析线程池的实现原理和线程的调度过程
什么时候线程会出现僵死

Spring有哪些优势
Spring源码
SpringBoot比Spring做了哪些改进
Spring5比Spring4做了哪些改进

MVCC一种机制

Spring的事务一种实现原理

JDK动态代理和CGLIB的区别，为什么JDK动态代理只能使用接口实现，而CGLIB可以用子类实现和接口实现

redis中bitmap的一个实现机制

B树和B+树的区别，为啥B+树的数据都在叶子节点上

M阶B树（B-树）特点
1. 一种二叉搜索树。
2. 除根节点外的所有非叶节点至少含有（M/2（向上取整）-1）个关键字，每个节点最多有M-1个关键字，并且以升序排列。所以M阶B树的除根节点外的所有非叶节点的关键字取值区间为[M/2-1(向上取整),M-1]。
3. 每个节点最多有M-1个关键字。
4. 优点：B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。


M阶B+数特点
1. 有n棵子树的非叶子结点中含有n个关键字（b树是n-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（b树是每个关键字都保存数据）。
2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接（叶子节点组成一个链表）。
3. 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
4. 通常在b+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。
5. 同一个数字会在不同节点中重复出现，根节点的最大元素就是b+树的最大元素。
6. 优点：所有的叶子结点使用链表相连，便于区间查找和遍历。B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。
7. 优点：b+树的中间节点不保存数据，能容纳更多节点元素

B树与B+树的区别
1. B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。
2. B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
3. B树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整)-1,m-1](根节点为[1,m-1])，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整),m](根节点为[1,m])，具有n个关键字的节点包含（n）棵子树。
4. B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。

>考虑磁盘IO的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。
所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，m的大小取决于磁盘页的大小。



红黑树的数据结构
1. 每个结点是黑色或者红色。
2. 根结点是黑色。
3. 每个叶子结点（NIL）是黑色。 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]
4. 如果一个结点是红色的，则它的子结点必须是黑色的。
5. 每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]


