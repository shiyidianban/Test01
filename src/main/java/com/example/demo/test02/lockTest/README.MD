# java锁
[网址一](https://www.cnblogs.com/qifengshi/p/6831055.html)
[网址二](https://www.cnblogs.com/jyroy/p/11365935.html)
![a1.png](../../../../../../resources/img/lock.png)  

-  公平锁/非公平锁
-  可重入锁
-  独享锁/共享锁
-  互斥锁/读写锁
-  乐观锁/悲观锁
-  分段锁
-  偏向锁/轻量级锁/重量级锁
-  自旋锁

>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。

### 公平锁/非公平锁

    公平锁是指多个线程按照申请锁的顺序来获取锁。
    
    非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
    对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
    对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。
    
### 可重入锁
    
    可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
    说的有点抽象，下面会有一个代码的示例。
    对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。
    对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。
    
### 独享锁/共享锁

    独享锁是指该锁一次只能被一个线程所持有。
    共享锁是指该锁可被多个线程所持有。

    对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。
    读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。
    独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
    对于Synchronized而言，当然是独享锁。
    
### 互斥锁/读写锁

    上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
    互斥锁在Java中的具体实现就是ReentrantLock
    读写锁在Java中的具体实现就是ReadWriteLock
    
### 乐观锁/悲观锁

    乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
    悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
    乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
    
    从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
    悲观锁在Java中的使用，就是利用各种锁。
    乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。
    
>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。
 
CAS算法涉及到三个操作数：

* 需要读写的内存值 v
* 进行比较的值 A
* 需要写入的值 B


    当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），
    否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
    
### 分段锁

    分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
    
    我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
    当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
    但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
    
    分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
    我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
    当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
    
    但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
    分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。
    
### 偏向锁/轻量级锁/重量级锁

    这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。
    
    偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    
    轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    
    重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
    
### 自旋锁/适应性自旋锁

    在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，
    线程挂起和恢复现场的花费可能会让系统得不偿失。
    如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，
    我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。
    
    而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，
    如果在自旋完成后前面锁定同步资源的线程已经释放了锁，
    那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。
    
    自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。
    如果锁被占用的时间很短，自旋等待的效果就会非常好。
    反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。
    所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数
    （默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。
    
    自旋锁的实现原理同样也是CAS，
    AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，
    如果修改数值失败则通过循环来执行自旋，直至修改成功。
    
    自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，
    并且引入了自适应的自旋锁（适应性自旋锁）。
    
    自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
    如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，
    那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。
    如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，
    直接阻塞线程，避免浪费处理器资源。
    
    在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。